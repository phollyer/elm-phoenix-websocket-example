/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "../deps/phoenix/priv/static/phoenix.js":
/*!**********************************************!*\
  !*** ../deps/phoenix/priv/static/phoenix.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("!function (e, t) {\n   true ? module.exports = t() : undefined;\n}(this, function () {\n  return function (e) {\n    var t = {};\n\n    function n(i) {\n      if (t[i]) return t[i].exports;\n      var o = t[i] = {\n        i: i,\n        l: !1,\n        exports: {}\n      };\n      return e[i].call(o.exports, o, o.exports, n), o.l = !0, o.exports;\n    }\n\n    return n.m = e, n.c = t, n.d = function (e, t, i) {\n      n.o(e, t) || Object.defineProperty(e, t, {\n        enumerable: !0,\n        get: i\n      });\n    }, n.r = function (e) {\n      \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {\n        value: \"Module\"\n      }), Object.defineProperty(e, \"__esModule\", {\n        value: !0\n      });\n    }, n.t = function (e, t) {\n      if (1 & t && (e = n(e)), 8 & t) return e;\n      if (4 & t && \"object\" == typeof e && e && e.__esModule) return e;\n      var i = Object.create(null);\n      if (n.r(i), Object.defineProperty(i, \"default\", {\n        enumerable: !0,\n        value: e\n      }), 2 & t && \"string\" != typeof e) for (var o in e) n.d(i, o, function (t) {\n        return e[t];\n      }.bind(null, o));\n      return i;\n    }, n.n = function (e) {\n      var t = e && e.__esModule ? function () {\n        return e.default;\n      } : function () {\n        return e;\n      };\n      return n.d(t, \"a\", t), t;\n    }, n.o = function (e, t) {\n      return Object.prototype.hasOwnProperty.call(e, t);\n    }, n.p = \"\", n(n.s = 0);\n  }([function (e, t, n) {\n    (function (t) {\n      e.exports = t.Phoenix = n(2);\n    }).call(this, n(1));\n  }, function (e, t) {\n    var n;\n\n    n = function () {\n      return this;\n    }();\n\n    try {\n      n = n || new Function(\"return this\")();\n    } catch (e) {\n      \"object\" == typeof window && (n = window);\n    }\n\n    e.exports = n;\n  }, function (e, t, n) {\n    \"use strict\";\n\n    function i(e) {\n      return function (e) {\n        if (Array.isArray(e)) return a(e);\n      }(e) || function (e) {\n        if (\"undefined\" != typeof Symbol && Symbol.iterator in Object(e)) return Array.from(e);\n      }(e) || s(e) || function () {\n        throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n      }();\n    }\n\n    function o(e) {\n      return (o = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (e) {\n        return typeof e;\n      } : function (e) {\n        return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n      })(e);\n    }\n\n    function r(e, t) {\n      return function (e) {\n        if (Array.isArray(e)) return e;\n      }(e) || function (e, t) {\n        if (\"undefined\" == typeof Symbol || !(Symbol.iterator in Object(e))) return;\n        var n = [],\n            i = !0,\n            o = !1,\n            r = void 0;\n\n        try {\n          for (var s, a = e[Symbol.iterator](); !(i = (s = a.next()).done) && (n.push(s.value), !t || n.length !== t); i = !0);\n        } catch (e) {\n          o = !0, r = e;\n        } finally {\n          try {\n            i || null == a.return || a.return();\n          } finally {\n            if (o) throw r;\n          }\n        }\n\n        return n;\n      }(e, t) || s(e, t) || function () {\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n      }();\n    }\n\n    function s(e, t) {\n      if (e) {\n        if (\"string\" == typeof e) return a(e, t);\n        var n = Object.prototype.toString.call(e).slice(8, -1);\n        return \"Object\" === n && e.constructor && (n = e.constructor.name), \"Map\" === n || \"Set\" === n ? Array.from(n) : \"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? a(e, t) : void 0;\n      }\n    }\n\n    function a(e, t) {\n      (null == t || t > e.length) && (t = e.length);\n\n      for (var n = 0, i = new Array(t); n < t; n++) i[n] = e[n];\n\n      return i;\n    }\n\n    function c(e, t) {\n      if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function u(e, t) {\n      for (var n = 0; n < t.length; n++) {\n        var i = t[n];\n        i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n      }\n    }\n\n    function h(e, t, n) {\n      return t && u(e.prototype, t), n && u(e, n), e;\n    }\n\n    n.r(t), n.d(t, \"Channel\", function () {\n      return _;\n    }), n.d(t, \"Serializer\", function () {\n      return H;\n    }), n.d(t, \"Socket\", function () {\n      return U;\n    }), n.d(t, \"LongPoll\", function () {\n      return D;\n    }), n.d(t, \"Ajax\", function () {\n      return M;\n    }), n.d(t, \"Presence\", function () {\n      return N;\n    });\n\n    var l = \"undefined\" != typeof self ? self : null,\n        f = \"undefined\" != typeof window ? window : null,\n        d = l || f || void 0,\n        p = 0,\n        v = 1,\n        y = 2,\n        m = 3,\n        g = \"closed\",\n        k = \"errored\",\n        b = \"joined\",\n        j = \"joining\",\n        C = \"leaving\",\n        E = \"phx_close\",\n        R = \"phx_error\",\n        T = \"phx_join\",\n        S = \"phx_reply\",\n        w = \"phx_leave\",\n        A = [E, R, T, S, w],\n        L = \"longpoll\",\n        x = \"websocket\",\n        O = function (e) {\n      if (\"function\" == typeof e) return e;\n      return function () {\n        return e;\n      };\n    },\n        P = function () {\n      function e(t, n, i, o) {\n        c(this, e), this.channel = t, this.event = n, this.payload = i || function () {\n          return {};\n        }, this.receivedResp = null, this.timeout = o, this.timeoutTimer = null, this.recHooks = [], this.sent = !1;\n      }\n\n      return h(e, [{\n        key: \"resend\",\n        value: function (e) {\n          this.timeout = e, this.reset(), this.send();\n        }\n      }, {\n        key: \"send\",\n        value: function () {\n          this.hasReceived(\"timeout\") || (this.startTimeout(), this.sent = !0, this.channel.socket.push({\n            topic: this.channel.topic,\n            event: this.event,\n            payload: this.payload(),\n            ref: this.ref,\n            join_ref: this.channel.joinRef()\n          }));\n        }\n      }, {\n        key: \"receive\",\n        value: function (e, t) {\n          return this.hasReceived(e) && t(this.receivedResp.response), this.recHooks.push({\n            status: e,\n            callback: t\n          }), this;\n        }\n      }, {\n        key: \"reset\",\n        value: function () {\n          this.cancelRefEvent(), this.ref = null, this.refEvent = null, this.receivedResp = null, this.sent = !1;\n        }\n      }, {\n        key: \"matchReceive\",\n        value: function (e) {\n          var t = e.status,\n              n = e.response;\n          e.ref;\n          this.recHooks.filter(function (e) {\n            return e.status === t;\n          }).forEach(function (e) {\n            return e.callback(n);\n          });\n        }\n      }, {\n        key: \"cancelRefEvent\",\n        value: function () {\n          this.refEvent && this.channel.off(this.refEvent);\n        }\n      }, {\n        key: \"cancelTimeout\",\n        value: function () {\n          clearTimeout(this.timeoutTimer), this.timeoutTimer = null;\n        }\n      }, {\n        key: \"startTimeout\",\n        value: function () {\n          var e = this;\n          this.timeoutTimer && this.cancelTimeout(), this.ref = this.channel.socket.makeRef(), this.refEvent = this.channel.replyEventName(this.ref), this.channel.on(this.refEvent, function (t) {\n            e.cancelRefEvent(), e.cancelTimeout(), e.receivedResp = t, e.matchReceive(t);\n          }), this.timeoutTimer = setTimeout(function () {\n            e.trigger(\"timeout\", {});\n          }, this.timeout);\n        }\n      }, {\n        key: \"hasReceived\",\n        value: function (e) {\n          return this.receivedResp && this.receivedResp.status === e;\n        }\n      }, {\n        key: \"trigger\",\n        value: function (e, t) {\n          this.channel.trigger(this.refEvent, {\n            status: e,\n            response: t\n          });\n        }\n      }]), e;\n    }(),\n        _ = function () {\n      function e(t, n, i) {\n        var o = this;\n        c(this, e), this.state = g, this.topic = t, this.params = O(n || {}), this.socket = i, this.bindings = [], this.bindingRef = 0, this.timeout = this.socket.timeout, this.joinedOnce = !1, this.joinPush = new P(this, T, this.params, this.timeout), this.pushBuffer = [], this.stateChangeRefs = [], this.rejoinTimer = new J(function () {\n          o.socket.isConnected() && o.rejoin();\n        }, this.socket.rejoinAfterMs), this.stateChangeRefs.push(this.socket.onError(function () {\n          return o.rejoinTimer.reset();\n        })), this.stateChangeRefs.push(this.socket.onOpen(function () {\n          o.rejoinTimer.reset(), o.isErrored() && o.rejoin();\n        })), this.joinPush.receive(\"ok\", function () {\n          o.state = b, o.rejoinTimer.reset(), o.pushBuffer.forEach(function (e) {\n            return e.send();\n          }), o.pushBuffer = [];\n        }), this.joinPush.receive(\"error\", function () {\n          o.state = k, o.socket.isConnected() && o.rejoinTimer.scheduleTimeout();\n        }), this.onClose(function () {\n          o.rejoinTimer.reset(), o.socket.hasLogger() && o.socket.log(\"channel\", \"close \".concat(o.topic, \" \").concat(o.joinRef())), o.state = g, o.socket.remove(o);\n        }), this.onError(function (e) {\n          o.socket.hasLogger() && o.socket.log(\"channel\", \"error \".concat(o.topic), e), o.isJoining() && o.joinPush.reset(), o.state = k, o.socket.isConnected() && o.rejoinTimer.scheduleTimeout();\n        }), this.joinPush.receive(\"timeout\", function () {\n          o.socket.hasLogger() && o.socket.log(\"channel\", \"timeout \".concat(o.topic, \" (\").concat(o.joinRef(), \")\"), o.joinPush.timeout), new P(o, w, O({}), o.timeout).send(), o.state = k, o.joinPush.reset(), o.socket.isConnected() && o.rejoinTimer.scheduleTimeout();\n        }), this.on(S, function (e, t) {\n          o.trigger(o.replyEventName(t), e);\n        });\n      }\n\n      return h(e, [{\n        key: \"join\",\n        value: function () {\n          var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.timeout;\n          if (this.joinedOnce) throw new Error(\"tried to join multiple times. 'join' can only be called a single time per channel instance\");\n          return this.timeout = e, this.joinedOnce = !0, this.rejoin(), this.joinPush;\n        }\n      }, {\n        key: \"onClose\",\n        value: function (e) {\n          this.on(E, e);\n        }\n      }, {\n        key: \"onError\",\n        value: function (e) {\n          return this.on(R, function (t) {\n            return e(t);\n          });\n        }\n      }, {\n        key: \"on\",\n        value: function (e, t) {\n          var n = this.bindingRef++;\n          return this.bindings.push({\n            event: e,\n            ref: n,\n            callback: t\n          }), n;\n        }\n      }, {\n        key: \"off\",\n        value: function (e, t) {\n          this.bindings = this.bindings.filter(function (n) {\n            return !(n.event === e && (void 0 === t || t === n.ref));\n          });\n        }\n      }, {\n        key: \"canPush\",\n        value: function () {\n          return this.socket.isConnected() && this.isJoined();\n        }\n      }, {\n        key: \"push\",\n        value: function (e, t) {\n          var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.timeout;\n          if (!this.joinedOnce) throw new Error(\"tried to push '\".concat(e, \"' to '\").concat(this.topic, \"' before joining. Use channel.join() before pushing events\"));\n          var i = new P(this, e, function () {\n            return t;\n          }, n);\n          return this.canPush() ? i.send() : (i.startTimeout(), this.pushBuffer.push(i)), i;\n        }\n      }, {\n        key: \"leave\",\n        value: function () {\n          var e = this,\n              t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.timeout;\n          this.rejoinTimer.reset(), this.joinPush.cancelTimeout(), this.state = C;\n\n          var n = function () {\n            e.socket.hasLogger() && e.socket.log(\"channel\", \"leave \".concat(e.topic)), e.trigger(E, \"leave\");\n          },\n              i = new P(this, w, O({}), t);\n\n          return i.receive(\"ok\", function () {\n            return n();\n          }).receive(\"timeout\", function () {\n            return n();\n          }), i.send(), this.canPush() || i.trigger(\"ok\", {}), i;\n        }\n      }, {\n        key: \"onMessage\",\n        value: function (e, t, n) {\n          return t;\n        }\n      }, {\n        key: \"isLifecycleEvent\",\n        value: function (e) {\n          return A.indexOf(e) >= 0;\n        }\n      }, {\n        key: \"isMember\",\n        value: function (e, t, n, i) {\n          return this.topic === e && (!i || i === this.joinRef() || !this.isLifecycleEvent(t) || (this.socket.hasLogger() && this.socket.log(\"channel\", \"dropping outdated message\", {\n            topic: e,\n            event: t,\n            payload: n,\n            joinRef: i\n          }), !1));\n        }\n      }, {\n        key: \"joinRef\",\n        value: function () {\n          return this.joinPush.ref;\n        }\n      }, {\n        key: \"rejoin\",\n        value: function () {\n          var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.timeout;\n          this.isLeaving() || (this.socket.leaveOpenTopic(this.topic), this.state = j, this.joinPush.resend(e));\n        }\n      }, {\n        key: \"trigger\",\n        value: function (e, t, n, i) {\n          var o = this.onMessage(e, t, n, i);\n          if (t && !o) throw new Error(\"channel onMessage callbacks must return the payload, modified or unmodified\");\n\n          for (var r = this.bindings.filter(function (t) {\n            return t.event === e;\n          }), s = 0; s < r.length; s++) {\n            r[s].callback(o, n, i || this.joinRef());\n          }\n        }\n      }, {\n        key: \"replyEventName\",\n        value: function (e) {\n          return \"chan_reply_\".concat(e);\n        }\n      }, {\n        key: \"isClosed\",\n        value: function () {\n          return this.state === g;\n        }\n      }, {\n        key: \"isErrored\",\n        value: function () {\n          return this.state === k;\n        }\n      }, {\n        key: \"isJoined\",\n        value: function () {\n          return this.state === b;\n        }\n      }, {\n        key: \"isJoining\",\n        value: function () {\n          return this.state === j;\n        }\n      }, {\n        key: \"isLeaving\",\n        value: function () {\n          return this.state === C;\n        }\n      }]), e;\n    }(),\n        H = {\n      HEADER_LENGTH: 1,\n      META_LENGTH: 4,\n      KINDS: {\n        push: 0,\n        reply: 1,\n        broadcast: 2\n      },\n      encode: function (e, t) {\n        if (e.payload.constructor === ArrayBuffer) return t(this.binaryEncode(e));\n        var n = [e.join_ref, e.ref, e.topic, e.event, e.payload];\n        return t(JSON.stringify(n));\n      },\n      decode: function (e, t) {\n        if (e.constructor === ArrayBuffer) return t(this.binaryDecode(e));\n        var n = r(JSON.parse(e), 5);\n        return t({\n          join_ref: n[0],\n          ref: n[1],\n          topic: n[2],\n          event: n[3],\n          payload: n[4]\n        });\n      },\n      binaryEncode: function (e) {\n        var t = e.join_ref,\n            n = e.ref,\n            i = e.event,\n            o = e.topic,\n            r = e.payload,\n            s = this.META_LENGTH + t.length + n.length + o.length + i.length,\n            a = new ArrayBuffer(this.HEADER_LENGTH + s),\n            c = new DataView(a),\n            u = 0;\n        c.setUint8(u++, this.KINDS.push), c.setUint8(u++, t.length), c.setUint8(u++, n.length), c.setUint8(u++, o.length), c.setUint8(u++, i.length), Array.from(t, function (e) {\n          return c.setUint8(u++, e.charCodeAt(0));\n        }), Array.from(n, function (e) {\n          return c.setUint8(u++, e.charCodeAt(0));\n        }), Array.from(o, function (e) {\n          return c.setUint8(u++, e.charCodeAt(0));\n        }), Array.from(i, function (e) {\n          return c.setUint8(u++, e.charCodeAt(0));\n        });\n        var h = new Uint8Array(a.byteLength + r.byteLength);\n        return h.set(new Uint8Array(a), 0), h.set(new Uint8Array(r), a.byteLength), h.buffer;\n      },\n      binaryDecode: function (e) {\n        var t = new DataView(e),\n            n = t.getUint8(0),\n            i = new TextDecoder();\n\n        switch (n) {\n          case this.KINDS.push:\n            return this.decodePush(e, t, i);\n\n          case this.KINDS.reply:\n            return this.decodeReply(e, t, i);\n\n          case this.KINDS.broadcast:\n            return this.decodeBroadcast(e, t, i);\n        }\n      },\n      decodePush: function (e, t, n) {\n        var i = t.getUint8(1),\n            o = t.getUint8(2),\n            r = t.getUint8(3),\n            s = this.HEADER_LENGTH + this.META_LENGTH - 1,\n            a = n.decode(e.slice(s, s + i));\n        s += i;\n        var c = n.decode(e.slice(s, s + o));\n        s += o;\n        var u = n.decode(e.slice(s, s + r));\n        return s += r, {\n          join_ref: a,\n          ref: null,\n          topic: c,\n          event: u,\n          payload: e.slice(s, e.byteLength)\n        };\n      },\n      decodeReply: function (e, t, n) {\n        var i = t.getUint8(1),\n            o = t.getUint8(2),\n            r = t.getUint8(3),\n            s = t.getUint8(4),\n            a = this.HEADER_LENGTH + this.META_LENGTH,\n            c = n.decode(e.slice(a, a + i));\n        a += i;\n        var u = n.decode(e.slice(a, a + o));\n        a += o;\n        var h = n.decode(e.slice(a, a + r));\n        a += r;\n        var l = n.decode(e.slice(a, a + s));\n        a += s;\n        var f = e.slice(a, e.byteLength);\n        return {\n          join_ref: c,\n          ref: u,\n          topic: h,\n          event: S,\n          payload: {\n            status: l,\n            response: f\n          }\n        };\n      },\n      decodeBroadcast: function (e, t, n) {\n        var i = t.getUint8(1),\n            o = t.getUint8(2),\n            r = this.HEADER_LENGTH + 2,\n            s = n.decode(e.slice(r, r + i));\n        r += i;\n        var a = n.decode(e.slice(r, r + o));\n        return r += o, {\n          join_ref: null,\n          ref: null,\n          topic: s,\n          event: a,\n          payload: e.slice(r, e.byteLength)\n        };\n      }\n    },\n        U = function () {\n      function e(t) {\n        var n = this,\n            i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n        c(this, e), this.stateChangeCallbacks = {\n          open: [],\n          close: [],\n          error: [],\n          message: []\n        }, this.channels = [], this.sendBuffer = [], this.ref = 0, this.timeout = i.timeout || 1e4, this.transport = i.transport || d.WebSocket || D, this.defaultEncoder = H.encode.bind(H), this.defaultDecoder = H.decode.bind(H), this.closeWasClean = !1, this.unloaded = !1, this.binaryType = i.binaryType || \"arraybuffer\", this.transport !== D ? (this.encode = i.encode || this.defaultEncoder, this.decode = i.decode || this.defaultDecoder) : (this.encode = this.defaultEncoder, this.decode = this.defaultDecoder), f && f.addEventListener && f.addEventListener(\"unload\", function (e) {\n          n.conn && (n.unloaded = !0, n.abnormalClose(\"unloaded\"));\n        }), this.heartbeatIntervalMs = i.heartbeatIntervalMs || 3e4, this.rejoinAfterMs = function (e) {\n          return i.rejoinAfterMs ? i.rejoinAfterMs(e) : [1e3, 2e3, 5e3][e - 1] || 1e4;\n        }, this.reconnectAfterMs = function (e) {\n          return n.unloaded ? 100 : i.reconnectAfterMs ? i.reconnectAfterMs(e) : [10, 50, 100, 150, 200, 250, 500, 1e3, 2e3][e - 1] || 5e3;\n        }, this.logger = i.logger || null, this.longpollerTimeout = i.longpollerTimeout || 2e4, this.params = O(i.params || {}), this.endPoint = \"\".concat(t, \"/\").concat(x), this.vsn = i.vsn || \"2.0.0\", this.heartbeatTimer = null, this.pendingHeartbeatRef = null, this.reconnectTimer = new J(function () {\n          n.teardown(function () {\n            return n.connect();\n          });\n        }, this.reconnectAfterMs);\n      }\n\n      return h(e, [{\n        key: \"protocol\",\n        value: function () {\n          return location.protocol.match(/^https/) ? \"wss\" : \"ws\";\n        }\n      }, {\n        key: \"endPointURL\",\n        value: function () {\n          var e = M.appendParams(M.appendParams(this.endPoint, this.params()), {\n            vsn: this.vsn\n          });\n          return \"/\" !== e.charAt(0) ? e : \"/\" === e.charAt(1) ? \"\".concat(this.protocol(), \":\").concat(e) : \"\".concat(this.protocol(), \"://\").concat(location.host).concat(e);\n        }\n      }, {\n        key: \"disconnect\",\n        value: function (e, t, n) {\n          this.closeWasClean = !0, this.reconnectTimer.reset(), this.teardown(e, t, n);\n        }\n      }, {\n        key: \"connect\",\n        value: function (e) {\n          var t = this;\n          e && (console && console.log(\"passing params to connect is deprecated. Instead pass :params to the Socket constructor\"), this.params = O(e)), this.conn || (this.closeWasClean = !1, this.conn = new this.transport(this.endPointURL()), this.conn.binaryType = this.binaryType, this.conn.timeout = this.longpollerTimeout, this.conn.onopen = function () {\n            return t.onConnOpen();\n          }, this.conn.onerror = function (e) {\n            return t.onConnError(e);\n          }, this.conn.onmessage = function (e) {\n            return t.onConnMessage(e);\n          }, this.conn.onclose = function (e) {\n            return t.onConnClose(e);\n          });\n        }\n      }, {\n        key: \"log\",\n        value: function (e, t, n) {\n          this.logger(e, t, n);\n        }\n      }, {\n        key: \"hasLogger\",\n        value: function () {\n          return null !== this.logger;\n        }\n      }, {\n        key: \"onOpen\",\n        value: function (e) {\n          var t = this.makeRef();\n          return this.stateChangeCallbacks.open.push([t, e]), t;\n        }\n      }, {\n        key: \"onClose\",\n        value: function (e) {\n          var t = this.makeRef();\n          return this.stateChangeCallbacks.close.push([t, e]), t;\n        }\n      }, {\n        key: \"onError\",\n        value: function (e) {\n          var t = this.makeRef();\n          return this.stateChangeCallbacks.error.push([t, e]), t;\n        }\n      }, {\n        key: \"onMessage\",\n        value: function (e) {\n          var t = this.makeRef();\n          return this.stateChangeCallbacks.message.push([t, e]), t;\n        }\n      }, {\n        key: \"onConnOpen\",\n        value: function () {\n          this.hasLogger() && this.log(\"transport\", \"connected to \".concat(this.endPointURL())), this.unloaded = !1, this.closeWasClean = !1, this.flushSendBuffer(), this.reconnectTimer.reset(), this.resetHeartbeat(), this.stateChangeCallbacks.open.forEach(function (e) {\n            return (0, r(e, 2)[1])();\n          });\n        }\n      }, {\n        key: \"resetHeartbeat\",\n        value: function () {\n          var e = this;\n          this.conn && this.conn.skipHeartbeat || (this.pendingHeartbeatRef = null, clearInterval(this.heartbeatTimer), this.heartbeatTimer = setInterval(function () {\n            return e.sendHeartbeat();\n          }, this.heartbeatIntervalMs));\n        }\n      }, {\n        key: \"teardown\",\n        value: function (e, t, n) {\n          var i = this;\n          if (!this.conn) return e && e();\n          this.waitForBufferDone(function () {\n            i.conn && (t ? i.conn.close(t, n || \"\") : i.conn.close()), i.waitForSocketClosed(function () {\n              i.conn && (i.conn.onclose = function () {}, i.conn = null), e && e();\n            });\n          });\n        }\n      }, {\n        key: \"waitForBufferDone\",\n        value: function (e) {\n          var t = this,\n              n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;\n          5 !== n && this.conn && this.conn.bufferedAmount ? setTimeout(function () {\n            t.waitForBufferDone(e, n + 1);\n          }, 150 * n) : e();\n        }\n      }, {\n        key: \"waitForSocketClosed\",\n        value: function (e) {\n          var t = this,\n              n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;\n          5 !== n && this.conn && this.conn.readyState !== m ? setTimeout(function () {\n            t.waitForSocketClosed(e, n + 1);\n          }, 150 * n) : e();\n        }\n      }, {\n        key: \"onConnClose\",\n        value: function (e) {\n          this.hasLogger() && this.log(\"transport\", \"close\", e), this.triggerChanError(), clearInterval(this.heartbeatTimer), this.closeWasClean || this.reconnectTimer.scheduleTimeout(), this.stateChangeCallbacks.close.forEach(function (t) {\n            return (0, r(t, 2)[1])(e);\n          });\n        }\n      }, {\n        key: \"onConnError\",\n        value: function (e) {\n          this.hasLogger() && this.log(\"transport\", e), this.triggerChanError(), this.stateChangeCallbacks.error.forEach(function (t) {\n            return (0, r(t, 2)[1])(e);\n          });\n        }\n      }, {\n        key: \"triggerChanError\",\n        value: function () {\n          this.channels.forEach(function (e) {\n            e.isErrored() || e.isLeaving() || e.isClosed() || e.trigger(R);\n          });\n        }\n      }, {\n        key: \"connectionState\",\n        value: function () {\n          switch (this.conn && this.conn.readyState) {\n            case p:\n              return \"connecting\";\n\n            case v:\n              return \"open\";\n\n            case y:\n              return \"closing\";\n\n            default:\n              return \"closed\";\n          }\n        }\n      }, {\n        key: \"isConnected\",\n        value: function () {\n          return \"open\" === this.connectionState();\n        }\n      }, {\n        key: \"remove\",\n        value: function (e) {\n          this.off(e.stateChangeRefs), this.channels = this.channels.filter(function (t) {\n            return t.joinRef() !== e.joinRef();\n          });\n        }\n      }, {\n        key: \"off\",\n        value: function (e) {\n          for (var t in this.stateChangeCallbacks) this.stateChangeCallbacks[t] = this.stateChangeCallbacks[t].filter(function (t) {\n            var n = r(t, 1)[0];\n            return -1 === e.indexOf(n);\n          });\n        }\n      }, {\n        key: \"channel\",\n        value: function (e) {\n          var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},\n              n = new _(e, t, this);\n          return this.channels.push(n), n;\n        }\n      }, {\n        key: \"push\",\n        value: function (e) {\n          var t = this;\n\n          if (this.hasLogger()) {\n            var n = e.topic,\n                i = e.event,\n                o = e.payload,\n                r = e.ref,\n                s = e.join_ref;\n            this.log(\"push\", \"\".concat(n, \" \").concat(i, \" (\").concat(s, \", \").concat(r, \")\"), o);\n          }\n\n          this.isConnected() ? this.encode(e, function (e) {\n            return t.conn.send(e);\n          }) : this.sendBuffer.push(function () {\n            return t.encode(e, function (e) {\n              return t.conn.send(e);\n            });\n          });\n        }\n      }, {\n        key: \"makeRef\",\n        value: function () {\n          var e = this.ref + 1;\n          return e === this.ref ? this.ref = 0 : this.ref = e, this.ref.toString();\n        }\n      }, {\n        key: \"sendHeartbeat\",\n        value: function () {\n          if (this.isConnected()) {\n            if (this.pendingHeartbeatRef) return this.pendingHeartbeatRef = null, this.hasLogger() && this.log(\"transport\", \"heartbeat timeout. Attempting to re-establish connection\"), void this.abnormalClose(\"heartbeat timeout\");\n            this.pendingHeartbeatRef = this.makeRef(), this.push({\n              topic: \"phoenix\",\n              event: \"heartbeat\",\n              payload: {},\n              ref: this.pendingHeartbeatRef\n            });\n          }\n        }\n      }, {\n        key: \"abnormalClose\",\n        value: function (e) {\n          this.closeWasClean = !1, this.conn.readyState === v && this.conn.close(1e3, e);\n        }\n      }, {\n        key: \"flushSendBuffer\",\n        value: function () {\n          this.isConnected() && this.sendBuffer.length > 0 && (this.sendBuffer.forEach(function (e) {\n            return e();\n          }), this.sendBuffer = []);\n        }\n      }, {\n        key: \"onConnMessage\",\n        value: function (e) {\n          var t = this;\n          this.decode(e.data, function (e) {\n            var n = e.topic,\n                i = e.event,\n                o = e.payload,\n                s = e.ref,\n                a = e.join_ref;\n            s && s === t.pendingHeartbeatRef && (t.pendingHeartbeatRef = null), t.hasLogger() && t.log(\"receive\", \"\".concat(o.status || \"\", \" \").concat(n, \" \").concat(i, \" \").concat(s && \"(\" + s + \")\" || \"\"), o);\n\n            for (var c = 0; c < t.channels.length; c++) {\n              var u = t.channels[c];\n              u.isMember(n, i, o, a) && u.trigger(i, o, s, a);\n            }\n\n            for (var h = 0; h < t.stateChangeCallbacks.message.length; h++) {\n              (0, r(t.stateChangeCallbacks.message[h], 2)[1])(e);\n            }\n          });\n        }\n      }, {\n        key: \"leaveOpenTopic\",\n        value: function (e) {\n          var t = this.channels.find(function (t) {\n            return t.topic === e && (t.isJoined() || t.isJoining());\n          });\n          t && (this.hasLogger() && this.log(\"transport\", 'leaving duplicate topic \"'.concat(e, '\"')), t.leave());\n        }\n      }]), e;\n    }(),\n        D = function () {\n      function e(t) {\n        c(this, e), this.endPoint = null, this.token = null, this.skipHeartbeat = !0, this.onopen = function () {}, this.onerror = function () {}, this.onmessage = function () {}, this.onclose = function () {}, this.pollEndpoint = this.normalizeEndpoint(t), this.readyState = p, this.poll();\n      }\n\n      return h(e, [{\n        key: \"normalizeEndpoint\",\n        value: function (e) {\n          return e.replace(\"ws://\", \"http://\").replace(\"wss://\", \"https://\").replace(new RegExp(\"(.*)/\" + x), \"$1/\" + L);\n        }\n      }, {\n        key: \"endpointURL\",\n        value: function () {\n          return M.appendParams(this.pollEndpoint, {\n            token: this.token\n          });\n        }\n      }, {\n        key: \"closeAndRetry\",\n        value: function () {\n          this.close(), this.readyState = p;\n        }\n      }, {\n        key: \"ontimeout\",\n        value: function () {\n          this.onerror(\"timeout\"), this.closeAndRetry();\n        }\n      }, {\n        key: \"poll\",\n        value: function () {\n          var e = this;\n          this.readyState !== v && this.readyState !== p || M.request(\"GET\", this.endpointURL(), \"application/json\", null, this.timeout, this.ontimeout.bind(this), function (t) {\n            if (t) {\n              var n = t.status,\n                  i = t.token,\n                  o = t.messages;\n              e.token = i;\n            } else n = 0;\n\n            switch (n) {\n              case 200:\n                o.forEach(function (t) {\n                  return e.onmessage({\n                    data: t\n                  });\n                }), e.poll();\n                break;\n\n              case 204:\n                e.poll();\n                break;\n\n              case 410:\n                e.readyState = v, e.onopen(), e.poll();\n                break;\n\n              case 403:\n                e.onerror(), e.close();\n                break;\n\n              case 0:\n              case 500:\n                e.onerror(), e.closeAndRetry();\n                break;\n\n              default:\n                throw new Error(\"unhandled poll status \".concat(n));\n            }\n          });\n        }\n      }, {\n        key: \"send\",\n        value: function (e) {\n          var t = this;\n          M.request(\"POST\", this.endpointURL(), \"application/json\", e, this.timeout, this.onerror.bind(this, \"timeout\"), function (e) {\n            e && 200 === e.status || (t.onerror(e && e.status), t.closeAndRetry());\n          });\n        }\n      }, {\n        key: \"close\",\n        value: function (e, t) {\n          this.readyState = m, this.onclose();\n        }\n      }]), e;\n    }(),\n        M = function () {\n      function e() {\n        c(this, e);\n      }\n\n      return h(e, null, [{\n        key: \"request\",\n        value: function (e, t, n, i, o, r, s) {\n          if (d.XDomainRequest) {\n            var a = new XDomainRequest();\n            this.xdomainRequest(a, e, t, i, o, r, s);\n          } else {\n            var c = new d.XMLHttpRequest();\n            this.xhrRequest(c, e, t, n, i, o, r, s);\n          }\n        }\n      }, {\n        key: \"xdomainRequest\",\n        value: function (e, t, n, i, o, r, s) {\n          var a = this;\n          e.timeout = o, e.open(t, n), e.onload = function () {\n            var t = a.parseJSON(e.responseText);\n            s && s(t);\n          }, r && (e.ontimeout = r), e.onprogress = function () {}, e.send(i);\n        }\n      }, {\n        key: \"xhrRequest\",\n        value: function (e, t, n, i, o, r, s, a) {\n          var c = this;\n          e.open(t, n, !0), e.timeout = r, e.setRequestHeader(\"Content-Type\", i), e.onerror = function () {\n            a && a(null);\n          }, e.onreadystatechange = function () {\n            if (e.readyState === c.states.complete && a) {\n              var t = c.parseJSON(e.responseText);\n              a(t);\n            }\n          }, s && (e.ontimeout = s), e.send(o);\n        }\n      }, {\n        key: \"parseJSON\",\n        value: function (e) {\n          if (!e || \"\" === e) return null;\n\n          try {\n            return JSON.parse(e);\n          } catch (t) {\n            return console && console.log(\"failed to parse JSON response\", e), null;\n          }\n        }\n      }, {\n        key: \"serialize\",\n        value: function (e, t) {\n          var n = [];\n\n          for (var i in e) if (e.hasOwnProperty(i)) {\n            var r = t ? \"\".concat(t, \"[\").concat(i, \"]\") : i,\n                s = e[i];\n            \"object\" === o(s) ? n.push(this.serialize(s, r)) : n.push(encodeURIComponent(r) + \"=\" + encodeURIComponent(s));\n          }\n\n          return n.join(\"&\");\n        }\n      }, {\n        key: \"appendParams\",\n        value: function (e, t) {\n          if (0 === Object.keys(t).length) return e;\n          var n = e.match(/\\?/) ? \"&\" : \"?\";\n          return \"\".concat(e).concat(n).concat(this.serialize(t));\n        }\n      }]), e;\n    }();\n\n    M.states = {\n      complete: 4\n    };\n\n    var N = function () {\n      function e(t) {\n        var n = this,\n            i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n        c(this, e);\n        var o = i.events || {\n          state: \"presence_state\",\n          diff: \"presence_diff\"\n        };\n        this.state = {}, this.pendingDiffs = [], this.channel = t, this.joinRef = null, this.caller = {\n          onJoin: function () {},\n          onLeave: function () {},\n          onSync: function () {}\n        }, this.channel.on(o.state, function (t) {\n          var i = n.caller,\n              o = i.onJoin,\n              r = i.onLeave,\n              s = i.onSync;\n          n.joinRef = n.channel.joinRef(), n.state = e.syncState(n.state, t, o, r), n.pendingDiffs.forEach(function (t) {\n            n.state = e.syncDiff(n.state, t, o, r);\n          }), n.pendingDiffs = [], s();\n        }), this.channel.on(o.diff, function (t) {\n          var i = n.caller,\n              o = i.onJoin,\n              r = i.onLeave,\n              s = i.onSync;\n          n.inPendingSyncState() ? n.pendingDiffs.push(t) : (n.state = e.syncDiff(n.state, t, o, r), s());\n        });\n      }\n\n      return h(e, [{\n        key: \"onJoin\",\n        value: function (e) {\n          this.caller.onJoin = e;\n        }\n      }, {\n        key: \"onLeave\",\n        value: function (e) {\n          this.caller.onLeave = e;\n        }\n      }, {\n        key: \"onSync\",\n        value: function (e) {\n          this.caller.onSync = e;\n        }\n      }, {\n        key: \"list\",\n        value: function (t) {\n          return e.list(this.state, t);\n        }\n      }, {\n        key: \"inPendingSyncState\",\n        value: function () {\n          return !this.joinRef || this.joinRef !== this.channel.joinRef();\n        }\n      }], [{\n        key: \"syncState\",\n        value: function (e, t, n, i) {\n          var o = this,\n              r = this.clone(e),\n              s = {},\n              a = {};\n          return this.map(r, function (e, n) {\n            t[e] || (a[e] = n);\n          }), this.map(t, function (e, t) {\n            var n = r[e];\n\n            if (n) {\n              var i = t.metas.map(function (e) {\n                return e.phx_ref;\n              }),\n                  c = n.metas.map(function (e) {\n                return e.phx_ref;\n              }),\n                  u = t.metas.filter(function (e) {\n                return c.indexOf(e.phx_ref) < 0;\n              }),\n                  h = n.metas.filter(function (e) {\n                return i.indexOf(e.phx_ref) < 0;\n              });\n              u.length > 0 && (s[e] = t, s[e].metas = u), h.length > 0 && (a[e] = o.clone(n), a[e].metas = h);\n            } else s[e] = t;\n          }), this.syncDiff(r, {\n            joins: s,\n            leaves: a\n          }, n, i);\n        }\n      }, {\n        key: \"syncDiff\",\n        value: function (e, t, n, o) {\n          var r = t.joins,\n              s = t.leaves,\n              a = this.clone(e);\n          return n || (n = function () {}), o || (o = function () {}), this.map(r, function (e, t) {\n            var o = a[e];\n\n            if (a[e] = t, o) {\n              var r,\n                  s = a[e].metas.map(function (e) {\n                return e.phx_ref;\n              }),\n                  c = o.metas.filter(function (e) {\n                return s.indexOf(e.phx_ref) < 0;\n              });\n              (r = a[e].metas).unshift.apply(r, i(c));\n            }\n\n            n(e, o, t);\n          }), this.map(s, function (e, t) {\n            var n = a[e];\n\n            if (n) {\n              var i = t.metas.map(function (e) {\n                return e.phx_ref;\n              });\n              n.metas = n.metas.filter(function (e) {\n                return i.indexOf(e.phx_ref) < 0;\n              }), o(e, n, t), 0 === n.metas.length && delete a[e];\n            }\n          }), a;\n        }\n      }, {\n        key: \"list\",\n        value: function (e, t) {\n          return t || (t = function (e, t) {\n            return t;\n          }), this.map(e, function (e, n) {\n            return t(e, n);\n          });\n        }\n      }, {\n        key: \"map\",\n        value: function (e, t) {\n          return Object.getOwnPropertyNames(e).map(function (n) {\n            return t(n, e[n]);\n          });\n        }\n      }, {\n        key: \"clone\",\n        value: function (e) {\n          return JSON.parse(JSON.stringify(e));\n        }\n      }]), e;\n    }(),\n        J = function () {\n      function e(t, n) {\n        c(this, e), this.callback = t, this.timerCalc = n, this.timer = null, this.tries = 0;\n      }\n\n      return h(e, [{\n        key: \"reset\",\n        value: function () {\n          this.tries = 0, clearTimeout(this.timer);\n        }\n      }, {\n        key: \"scheduleTimeout\",\n        value: function () {\n          var e = this;\n          clearTimeout(this.timer), this.timer = setTimeout(function () {\n            e.tries = e.tries + 1, e.callback();\n          }, this.timerCalc(this.tries + 1));\n        }\n      }]), e;\n    }();\n  }]);\n});\n\n//# sourceURL=webpack:///../deps/phoenix/priv/static/phoenix.js?");

/***/ }),

/***/ "./elm/src/Main.elm":
/*!**************************!*\
  !*** ./elm/src/Main.elm ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("throw new Error(\"Module build failed (from ./node_modules/elm-webpack-loader/index.js):\\nError: Compiler process exited with error Compilation failed\\nCompiling ...-- AMBIGUOUS IMPORT -------------------------------------------- src/Configs.elm\\n\\nYou are trying to import a `Phoenix` module:\\n\\n7| import Phoenix\\n          ^^^^^^^\\nBut I found multiple modules with that name. One in the\\nphollyer/elm-phoenix-websocket package, and another defined locally in the\\n/Users/code/Production/Lib/elm/packages/elm-phoenix-websocket/src/Phoenix.elm\\nfile. I do not have a way to choose between them.\\n\\nTry changing the name of the locally defined module to clear up the ambiguity?\\n\\n                                                                  Configs  ↑    \\n====o======================================================================o====\\n    ↓  Session\\n\\n\\n-- AMBIGUOUS IMPORT -------------------------------------------- src/Session.elm\\n\\nYou are trying to import a `Phoenix` module:\\n\\n14| import Phoenix\\n           ^^^^^^^\\nBut I found multiple modules with that name. One in the\\nphollyer/elm-phoenix-websocket package, and another defined locally in the\\n/Users/code/Production/Lib/elm/packages/elm-phoenix-websocket/src/Phoenix.elm\\nfile. I do not have a way to choose between them.\\n\\nTry changing the name of the locally defined module to clear up the ambiguity?\\n\\n                                                                  Session  ↑    \\n====o======================================================================o====\\n    ↓  Page.ChatRooms\\n\\n\\n-- AMBIGUOUS IMPORT ------------------------------------- src/Page/ChatRooms.elm\\n\\nYou are trying to import a `Phoenix` module:\\n\\n14| import Phoenix\\n           ^^^^^^^\\nBut I found multiple modules with that name. One in the\\nphollyer/elm-phoenix-websocket package, and another defined locally in the\\n/Users/code/Production/Lib/elm/packages/elm-phoenix-websocket/src/Phoenix.elm\\nfile. I do not have a way to choose between them.\\n\\nTry changing the name of the locally defined module to clear up the ambiguity?\\n\\n                                                           Page.ChatRooms  ↑    \\n====o======================================================================o====\\n    ↓  Utils\\n\\n\\n-- AMBIGUOUS IMPORT ---------------------------------------------- src/Utils.elm\\n\\nYou are trying to import a `Phoenix` module:\\n\\n10| import Phoenix\\n           ^^^^^^^\\nBut I found multiple modules with that name. One in the\\nphollyer/elm-phoenix-websocket package, and another defined locally in the\\n/Users/code/Production/Lib/elm/packages/elm-phoenix-websocket/src/Phoenix.elm\\nfile. I do not have a way to choose between them.\\n\\nTry changing the name of the locally defined module to clear up the ambiguity?\\n\\n                                                                    Utils  ↑    \\n====o======================================================================o====\\n    ↓  Internal.Push\\n\\n\\n-- AMBIGUOUS IMPORT - /Users/code/Production/Lib/elm/packages/elm-phoenix-websocket/src/Internal/Push.elm\\n\\nYou are trying to import a `Phoenix.Channel` module:\\n\\n34| import Phoenix.Channel as Channel exposing (Event, Payload, Topic)\\n           ^^^^^^^^^^^^^^^\\nBut I found multiple modules with that name. One in the\\nphollyer/elm-phoenix-websocket package, and another defined locally in the\\n/Users/code/Production/Lib/elm/packages/elm-phoenix-websocket/src/Phoenix/Channel.elm\\nfile. I do not have a way to choose between them.\\n\\nTry changing the name of the locally defined module to clear up the ambiguity?\\n\\n                                                            Internal.Push  ↑    \\n====o======================================================================o====\\n    ↓  Type.User\\n\\n\\n-- AMBIGUOUS IMPORT ------------------------------------------ src/Type/User.elm\\n\\nYou are trying to import a `Phoenix` module:\\n\\n47| import Phoenix\\n           ^^^^^^^\\nBut I found multiple modules with that name. One in the\\nphollyer/elm-phoenix-websocket package, and another defined locally in the\\n/Users/code/Production/Lib/elm/packages/elm-phoenix-websocket/src/Phoenix.elm\\nfile. I do not have a way to choose between them.\\n\\nTry changing the name of the locally defined module to clear up the ambiguity?\\n\\n                                                                Type.User  ↑    \\n====o======================================================================o====\\n    ↓  Page.SendAndReceive\\n\\n\\n-- AMBIGUOUS IMPORT -------------------------------- src/Page/SendAndReceive.elm\\n\\nYou are trying to import a `Phoenix` module:\\n\\n17| import Phoenix\\n           ^^^^^^^\\nBut I found multiple modules with that name. One in the\\nphollyer/elm-phoenix-websocket package, and another defined locally in the\\n/Users/code/Production/Lib/elm/packages/elm-phoenix-websocket/src/Phoenix.elm\\nfile. I do not have a way to choose between them.\\n\\nTry changing the name of the locally defined module to clear up the ambiguity?\\n\\n                                                      Page.SendAndReceive  ↑    \\n====o======================================================================o====\\n    ↓  Page.ControlTheSocketConnection\\n\\n\\n-- AMBIGUOUS IMPORT -------------------- src/Page/ControlTheSocketConnection.elm\\n\\nYou are trying to import a `Phoenix` module:\\n\\n16| import Phoenix\\n           ^^^^^^^\\nBut I found multiple modules with that name. One in the\\nphollyer/elm-phoenix-websocket package, and another defined locally in the\\n/Users/code/Production/Lib/elm/packages/elm-phoenix-websocket/src/Phoenix.elm\\nfile. I do not have a way to choose between them.\\n\\nTry changing the name of the locally defined module to clear up the ambiguity?\\n\\n                                          Page.ControlTheSocketConnection  ↑    \\n====o======================================================================o====\\n    ↓  Page.JoinAndLeaveChannels\\n\\n\\n-- AMBIGUOUS IMPORT -------------------------- src/Page/JoinAndLeaveChannels.elm\\n\\nYou are trying to import a `Phoenix` module:\\n\\n17| import Phoenix\\n           ^^^^^^^\\nBut I found multiple modules with that name. One in the\\nphollyer/elm-phoenix-websocket package, and another defined locally in the\\n/Users/code/Production/Lib/elm/packages/elm-phoenix-websocket/src/Phoenix.elm\\nfile. I do not have a way to choose between them.\\n\\nTry changing the name of the locally defined module to clear up the ambiguity?\\n\\n                                                Page.JoinAndLeaveChannels  ↑    \\n====o======================================================================o====\\n    ↓  Page.Home\\n\\n\\n-- AMBIGUOUS IMPORT ------------------------------------------ src/Page/Home.elm\\n\\nYou are trying to import a `Phoenix` module:\\n\\n14| import Phoenix\\n           ^^^^^^^\\nBut I found multiple modules with that name. One in the\\nphollyer/elm-phoenix-websocket package, and another defined locally in the\\n/Users/code/Production/Lib/elm/packages/elm-phoenix-websocket/src/Phoenix.elm\\nfile. I do not have a way to choose between them.\\n\\nTry changing the name of the locally defined module to clear up the ambiguity?\\n\\n                                                                Page.Home  ↑    \\n====o======================================================================o====\\n    ↓  Example.ConnectWithBadParams\\n\\n\\n-- AMBIGUOUS IMPORT ----------------------- src/Example/ConnectWithBadParams.elm\\n\\nYou are trying to import a `Phoenix` module:\\n\\n13| import Phoenix exposing (PhoenixMsg(..), SocketMessage(..))\\n           ^^^^^^^\\nBut I found multiple modules with that name. One in the\\nphollyer/elm-phoenix-websocket package, and another defined locally in the\\n/Users/code/Production/Lib/elm/packages/elm-phoenix-websocket/src/Phoenix.elm\\nfile. I do not have a way to choose between them.\\n\\nTry changing the name of the locally defined module to clear up the ambiguity?\\n\\n                                             Example.ConnectWithBadParams  ↑    \\n====o======================================================================o====\\n    ↓  Example.ConnectWithGoodParams\\n\\n\\n-- AMBIGUOUS IMPORT ---------------------- src/Example/ConnectWithGoodParams.elm\\n\\nYou are trying to import a `Phoenix` module:\\n\\n13| import Phoenix exposing (PhoenixMsg(..), SocketMessage(..))\\n           ^^^^^^^\\nBut I found multiple modules with that name. One in the\\nphollyer/elm-phoenix-websocket package, and another defined locally in the\\n/Users/code/Production/Lib/elm/packages/elm-phoenix-websocket/src/Phoenix.elm\\nfile. I do not have a way to choose between them.\\n\\nTry changing the name of the locally defined module to clear up the ambiguity?\\n\\n                                            Example.ConnectWithGoodParams  ↑    \\n====o======================================================================o====\\n    ↓  Example.JoinMultipleChannels\\n\\n\\n-- AMBIGUOUS IMPORT ----------------------- src/Example/JoinMultipleChannels.elm\\n\\nYou are trying to import a `Phoenix` module:\\n\\n12| import Phoenix exposing (ChannelResponse(..), PhoenixMsg(..))\\n           ^^^^^^^\\nBut I found multiple modules with that name. One in the\\nphollyer/elm-phoenix-websocket package, and another defined locally in the\\n/Users/code/Production/Lib/elm/packages/elm-phoenix-websocket/src/Phoenix.elm\\nfile. I do not have a way to choose between them.\\n\\nTry changing the name of the locally defined module to clear up the ambiguity?\\n\\n                                             Example.JoinMultipleChannels  ↑    \\n====o======================================================================o====\\n    ↓  Example.JoinWithBadParams\\n\\n\\n-- AMBIGUOUS IMPORT -------------------------- src/Example/JoinWithBadParams.elm\\n\\nYou are trying to import a `Phoenix` module:\\n\\n14| import Phoenix exposing (ChannelResponse(..), PhoenixMsg(..))\\n           ^^^^^^^\\nBut I found multiple modules with that name. One in the\\nphollyer/elm-phoenix-websocket package, and another defined locally in the\\n/Users/code/Production/Lib/elm/packages/elm-phoenix-websocket/src/Phoenix.elm\\nfile. I do not have a way to choose between them.\\n\\nTry changing the name of the locally defined module to clear up the ambiguity?\\n\\n                                                Example.JoinWithBadParams  ↑    \\n====o======================================================================o====\\n    ↓  Example.JoinWithGoodParams\\n\\n\\n-- AMBIGUOUS IMPORT ------------------------- src/Example/JoinWithGoodParams.elm\\n\\nYou are trying to import a `Phoenix` module:\\n\\n14| import Phoenix exposing (ChannelResponse(..), PhoenixMsg(..), SocketMessage(..))\\n           ^^^^^^^\\nBut I found multiple modules with that name. One in the\\nphollyer/elm-phoenix-websocket package, and another defined locally in the\\n/Users/code/Production/Lib/elm/packages/elm-phoenix-websocket/src/Phoenix.elm\\nfile. I do not have a way to choose between them.\\n\\nTry changing the name of the locally defined module to clear up the ambiguity?\\n\\n                                               Example.JoinWithGoodParams  ↑    \\n====o======================================================================o====\\n    ↓  Example.PushMultipleEvents\\n\\n\\n-- AMBIGUOUS IMPORT ------------------------- src/Example/PushMultipleEvents.elm\\n\\nYou are trying to import a `Phoenix` module:\\n\\n13| import Phoenix exposing (ChannelResponse(..), PhoenixMsg(..))\\n           ^^^^^^^\\nBut I found multiple modules with that name. One in the\\nphollyer/elm-phoenix-websocket package, and another defined locally in the\\n/Users/code/Production/Lib/elm/packages/elm-phoenix-websocket/src/Phoenix.elm\\nfile. I do not have a way to choose between them.\\n\\nTry changing the name of the locally defined module to clear up the ambiguity?\\n\\n                                               Example.PushMultipleEvents  ↑    \\n====o======================================================================o====\\n    ↓  Example.PushOneEvent\\n\\n\\n-- AMBIGUOUS IMPORT ------------------------------- src/Example/PushOneEvent.elm\\n\\nYou are trying to import a `Phoenix` module:\\n\\n13| import Phoenix exposing (ChannelResponse(..), PhoenixMsg(..))\\n           ^^^^^^^\\nBut I found multiple modules with that name. One in the\\nphollyer/elm-phoenix-websocket package, and another defined locally in the\\n/Users/code/Production/Lib/elm/packages/elm-phoenix-websocket/src/Phoenix.elm\\nfile. I do not have a way to choose between them.\\n\\nTry changing the name of the locally defined module to clear up the ambiguity?\\n\\n                                                     Example.PushOneEvent  ↑    \\n====o======================================================================o====\\n    ↓  View.Example\\n\\n\\n-- AMBIGUOUS IMPORT --------------------------------------- src/View/Example.elm\\n\\nYou are trying to import a `Phoenix` module:\\n\\n24| import Phoenix exposing (ChannelResponse(..), PhoenixMsg(..), SocketMessage(..))\\n           ^^^^^^^\\nBut I found multiple modules with that name. One in the\\nphollyer/elm-phoenix-websocket package, and another defined locally in the\\n/Users/code/Production/Lib/elm/packages/elm-phoenix-websocket/src/Phoenix.elm\\nfile. I do not have a way to choose between them.\\n\\nTry changing the name of the locally defined module to clear up the ambiguity?\\n\\n                                                             View.Example  ↑    \\n====o======================================================================o====\\n    ↓  Example.PushWithTimeout\\n\\n\\n-- AMBIGUOUS IMPORT ---------------------------- src/Example/PushWithTimeout.elm\\n\\nYou are trying to import a `Phoenix` module:\\n\\n13| import Phoenix exposing (ChannelResponse(..), PhoenixMsg(..), PushConfig, RetryStrategy(..))\\n           ^^^^^^^\\nBut I found multiple modules with that name. One in the\\nphollyer/elm-phoenix-websocket package, and another defined locally in the\\n/Users/code/Production/Lib/elm/packages/elm-phoenix-websocket/src/Phoenix.elm\\nfile. I do not have a way to choose between them.\\n\\nTry changing the name of the locally defined module to clear up the ambiguity?\\n\\n                                                  Example.PushWithTimeout  ↑    \\n====o======================================================================o====\\n    ↓  Example.ReceiveEvents\\n\\n\\n-- AMBIGUOUS IMPORT ------------------------------ src/Example/ReceiveEvents.elm\\n\\nYou are trying to import a `Phoenix` module:\\n\\n13| import Phoenix exposing (ChannelResponse(..), PhoenixMsg(..))\\n           ^^^^^^^\\nBut I found multiple modules with that name. One in the\\nphollyer/elm-phoenix-websocket package, and another defined locally in the\\n/Users/code/Production/Lib/elm/packages/elm-phoenix-websocket/src/Phoenix.elm\\nfile. I do not have a way to choose between them.\\n\\nTry changing the name of the locally defined module to clear up the ambiguity?\\n\\n                                                    Example.ReceiveEvents  ↑    \\n====o======================================================================o====\\n    ↓  Example.SimpleConnect\\n\\n\\n-- AMBIGUOUS IMPORT ------------------------------ src/Example/SimpleConnect.elm\\n\\nYou are trying to import a `Phoenix` module:\\n\\n12| import Phoenix exposing (PhoenixMsg(..), SocketMessage(..))\\n           ^^^^^^^\\nBut I found multiple modules with that name. One in the\\nphollyer/elm-phoenix-websocket package, and another defined locally in the\\n/Users/code/Production/Lib/elm/packages/elm-phoenix-websocket/src/Phoenix.elm\\nfile. I do not have a way to choose between them.\\n\\nTry changing the name of the locally defined module to clear up the ambiguity?\\n\\n                                                    Example.SimpleConnect  ↑    \\n====o======================================================================o====\\n    ↓  Example.SimpleJoinAndLeave\\n\\n\\n-- AMBIGUOUS IMPORT ------------------------- src/Example/SimpleJoinAndLeave.elm\\n\\nYou are trying to import a `Phoenix` module:\\n\\n12| import Phoenix exposing (ChannelResponse(..), PhoenixMsg(..), SocketMessage(..), SocketState(..))\\n           ^^^^^^^\\nBut I found multiple modules with that name. One in the\\nphollyer/elm-phoenix-websocket package, and another defined locally in the\\n/Users/code/Production/Lib/elm/packages/elm-phoenix-websocket/src/Phoenix.elm\\nfile. I do not have a way to choose between them.\\n\\nTry changing the name of the locally defined module to clear up the ambiguity?\\n\\n                                               Example.SimpleJoinAndLeave  ↑    \\n====o======================================================================o====\\n    ↓  Example.MultiRoomChat\\n\\n\\n-- AMBIGUOUS IMPORT ------------------------------ src/Example/MultiRoomChat.elm\\n\\nYou are trying to import a `Phoenix` module:\\n\\n18| import Phoenix exposing (ChannelResponse(..), JoinConfig, PhoenixMsg(..), PushConfig, pushConfig)\\n           ^^^^^^^\\nBut I found multiple modules with that name. One in the\\nphollyer/elm-phoenix-websocket package, and another defined locally in the\\n/Users/code/Production/Lib/elm/packages/elm-phoenix-websocket/src/Phoenix.elm\\nfile. I do not have a way to choose between them.\\n\\nTry changing the name of the locally defined module to clear up the ambiguity?\\n\\n\\rDetected problems in 23 modules.\\n\\n    at ChildProcess.<anonymous> (/Users/code/Production/Apps/elm-phoenix-websocket-example/assets/node_modules/node-elm-compiler/dist/index.js:131:35)\\n    at ChildProcess.emit (events.js:315:20)\\n    at maybeClose (internal/child_process.js:1051:16)\\n    at Process.ChildProcess._handle.onexit (internal/child_process.js:287:5)\");\n\n//# sourceURL=webpack:///./elm/src/Main.elm?");

/***/ }),

/***/ "./js/app.js":
/*!*******************!*\
  !*** ./js/app.js ***!
  \*******************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var phoenix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! phoenix */ \"../deps/phoenix/priv/static/phoenix.js\");\n/* harmony import */ var phoenix__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(phoenix__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _elm_src_Main_elm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../elm/src/Main.elm */ \"./elm/src/Main.elm\");\n/* harmony import */ var _elm_src_Main_elm__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_elm_src_Main_elm__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _elmPhoenixWebSocket__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./elmPhoenixWebSocket */ \"./js/elmPhoenixWebSocket.js\");\n\n\n\nvar flags = {\n  height: window.innerHeight,\n  width: window.innerWidth,\n  vsn: document.querySelector(\"#body\").dataset.vsn\n};\nvar app = _elm_src_Main_elm__WEBPACK_IMPORTED_MODULE_1__[\"Elm\"].Main.init({\n  flags: flags\n});\n_elmPhoenixWebSocket__WEBPACK_IMPORTED_MODULE_2__[\"default\"].init(app.ports, phoenix__WEBPACK_IMPORTED_MODULE_0__[\"Socket\"], phoenix__WEBPACK_IMPORTED_MODULE_0__[\"Presence\"]);\n\n//# sourceURL=webpack:///./js/app.js?");

/***/ }),

/***/ "./js/elmPhoenixWebSocket.js":
/*!***********************************!*\
  !*** ./js/elmPhoenixWebSocket.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n////////////////////////////////////////////////////////\n//\n// elmPhoenixWebSocket.js\n// JavaScript runtime code for Elm-Phoenix-WebSocket\n// Copyright (c) 2019 Paul Hollyer <paul@hollyer.me.uk>\n// Some rights reserved.\n// Distributed under the MIT License\n// See LICENSE\n//\n////////////////////////////////////////////////////////\n\n/*\n\n   This is Version 3\n\n   For Version 2, go to:\n\n   https://github.com/phollyer/elm-phoenix-websocket/tree/2.0.0\n\n   For Version 1.1.0\n\n   https://github.com/phollyer/elm-phoenix-websocket/tree/1.1.0\n\n*/\nvar ElmPhoenixWebSocket = {\n  /* The Phoenix Socket class imported with `import {Socket} from \"phoenix\"`.\n      This is passed in as a parameter to the `init` function.\n  */\n  phoenixSocket: {},\n  // The Phoenix JS socket instantiated with `new phoenixSocket(url, params)`.\n  socket: {},\n\n  /* A map of channels with each topic as the key.\n      This is used to store multiple channels.\n  */\n  channels: {},\n\n  /* A map of lists of incoming channel events with the topic as the key.\n   */\n  events: {},\n\n  /* The Phoenix Presence class imported with `import {Presence} from \"phoenix\"`.\n      This is passed in as a parameter to the `init` function.\n   */\n  phoenixPresence: {},\n\n  /* A map of presence data with the channel topic as the key.\n      This is used to store the presence data when multiple channels are used.\n  */\n  presences: {},\n  // The Elm ports object.\n  elmPorts: {},\n  // The endpoint url.\n  url: \"/socket\",\n\n  /* This is used in the onClose and onOpen callback functions because\n     onClose does not provide enough information to determine if the\n     user was:\n          1. Denied access by the Elixir socket, or\n         2. The internet connection dropped out\n      We assume the user will be denied, and only set this to true when the\n     socket connects successfully. Therefore we currently assume that if\n     this value is true when onClose fires, it is because the network has\n     dropped out.\n  */\n  allowReconnect: false,\n\n  /* init\n       Set up the ports, socket and presence.\n       Send the socket info back to Phoenix.elm\n  */\n  init: function init(ports, socket, presence) {\n    var _this = this;\n\n    this.elmPorts = ports;\n    this.elmPorts.phoenixSend.subscribe(function (params) {\n      return _this[params.msg](params.payload);\n    });\n    this.phoenixSocket = socket;\n    this.phoenixPresence = presence;\n    this.socket = new this.phoenixSocket(this.url, {});\n    this.info();\n  },\n\n  /********** Socket **********/\n\n  /* connect\n       Connect to the socket.\n       Set up the callback functions.\n       data <maybe object>\n          params <maybe object>\n              Data to be sent to the socket when attempting to connect, such\n              as authentication params.\n           options <maybe object>\n              Options to set on the socket when creating it.\n  */\n  connect: function connect(data) {\n    var _this2 = this;\n\n    this.socket = new this.phoenixSocket(this.url, this.setOptionsAndParams(data));\n    this.socket.onError(function (resp) {\n      return _this2.socketSend(\"Error\", {\n        reason: \"\"\n      });\n    });\n    this.socket.onMessage(function (resp) {\n      return _this2.onMessage(resp);\n    });\n    this.socket.onOpen(function (resp) {\n      _this2.socketSend(\"Opened\", resp);\n\n      _this2.info();\n\n      _this2.allowReconnect = true;\n    });\n    this.socket.onClose(function (resp) {\n      if (resp.code != 1000) {\n        if (_this2.allowReconnect) {\n          /* The socket has closed unexpectedly after having been open,\n             so we assume the closure was due to a drop in the network.\n          */\n          _this2.socketSend(\"Error\", {\n            reason: \"Unreachable\"\n          });\n        } else {\n          /* The socket closes, and allowReconnect is still equal to\n             false, so we assume the socket has denied the connection for\n             some reason.\n              Therefore, reset the reconnectTimer so that we don't keep\n             trying to connect with the same bad creds.\n           */\n          _this2.socket.reconnectTimer.reset();\n          /* One known case exists that isn't covered here.\n              If the application or the server is down, but the network\n             up, then we still end up here, sending back \"Denied\". This\n             is the wrong response for this scenario.\n              TODO:\n              Send an ajax request to the server to determine if it is the\n             application or the server that is down.\n              If the server is unreachable, send an ajax request to an\n             alternative server. As it is unlikely that both servers will\n             be down at the same time, we can then assume that the user\n             does not have access to the internet.\n              This would require the user to opt in and provide additional\n             config details to be used by the ajax requests.\n           */\n\n\n          _this2.socketSend(\"Error\", {\n            reason: \"Denied\"\n          });\n        }\n      }\n\n      _this2.info();\n\n      _this2.socketSend(\"Closed\", resp);\n    });\n    this.info(); // Ensure this is set to false before trying to connect.\n\n    this.allowReconnect = false;\n    this.socketSend(\"Connecting\", {});\n    this.socket.connect();\n  },\n\n  /* setOptionsAndParams\n       data <object>\n          params <maybe object>\n              Any data to be sent to the socket when connecting, such as\n              authentication params.\n           options <maybe object>\n              Any options to set on the socket when connecting.\n  */\n  setOptionsAndParams: function setOptionsAndParams(data) {\n    if (data) {\n      var options = data.options;\n\n      if (options) {\n        if (options.reconnectSteppedBackoff && options.reconnectAfterMs) {\n          options.reconnectAfterMs = function (tries) {\n            return options.reconnectSteppedBackoff[tries - 1] || options.reconnectAfterMs;\n          };\n\n          delete options.reconnectSteppedBackoff;\n        }\n\n        if (options.rejoinSteppedBackoff && options.rejoinAfterMs) {\n          options.rejoinAfterMs = function (tries) {\n            return options.rejoinSteppedBackoff[tries - 1] || options.rejoinAfterMs;\n          };\n\n          delete options.rejoinSteppedBackoff;\n        }\n\n        if (options.logger) {\n          options.logger = this.logger;\n        }\n      }\n\n      if (data.params && options) {\n        options.params = data.params;\n      } else if (data.params) {\n        options = data;\n      }\n\n      return options;\n    }\n\n    return null;\n  },\n\n  /* disconnect\n       Disconnect from the socket.\n  */\n  disconnect: function disconnect(params) {\n    this.channels = {};\n    this.presences = {};\n    this.events = {};\n    this.socketSend(\"Disconnecting\", {});\n    this.socket.disconnect(function () {}, params.code);\n  },\n\n  /* onMessage */\n  onMessage: function onMessage(resp) {\n    if (resp.topic == \"phoenix\") {\n      this.socketSend(\"Heartbeat\", resp);\n    } else if (resp.event.indexOf(\"presence\") == 0) {\n      this.socketSend(\"Presence\", resp);\n    } else {\n      this.socketSend(\"Channel\", resp);\n    }\n  },\n\n  /***** Socket Information *****/\n\n  /* connectionState\n       Retrieve the current connection state and send it back to Elm as a String.\n  */\n  connectionState: function connectionState() {\n    this.socketSend(\"ConnectionState\", this.socket.connectionState());\n  },\n\n  /* endpoint\n       Retrieve the current endpoint and send it back to Elm as a String.\n  */\n  endPointURL: function endPointURL() {\n    this.socketSend(\"EndPointURL\", this.socket.endPointURL());\n  },\n\n  /* hasLogger\n       Determine if a logger has been set on the socket and send it back to\n      Elm as a Maybe Bool.\n       The hasLogger function does not exist on all versions of PhoenixJS so\n      we check it exists before calling it.\n       If it does exist, we call the function and send back the result.\n       If it does not exist, we simply send back `null` to signify that the\n      function is not available.\n  */\n  hasLogger: function hasLogger() {\n    this.socketSend(\"HasLogger\", this.getHasLogger());\n  },\n  getHasLogger: function getHasLogger() {\n    if (this.socket.hasLogger) {\n      return this.socket.hasLogger();\n    } else {\n      return null;\n    }\n  },\n\n  /* isConnected\n       Retrieve whether the socket is currently connected and send it back to\n      Elm as a Bool.\n  */\n  isConnected: function isConnected() {\n    this.socketSend(\"IsConnected\", this.socket.isConnected());\n  },\n\n  /* makeRef\n       Retrieve the next message ref, accounting for overflows, and send it\n      back to Elm as a String.\n  */\n  makeRef: function makeRef() {\n    this.socketSend(\"MakeRef\", this.socket.makeRef());\n  },\n\n  /* protocol\n       Retrieve the current protocol and send it back to Elm as a String.\n  */\n  protocol: function protocol() {\n    this.socketSend(\"Protocol\", this.socket.protocol());\n  },\n\n  /* info\n       Retrieve all the socket info and send it back to Elm.\n  */\n  info: function info() {\n    var info = {\n      connectionState: this.socket.connectionState(),\n      endPointURL: this.socket.endPointURL(),\n      hasLogger: this.getHasLogger(),\n      isConnected: this.socket.isConnected(),\n      nextMessageRef: this.socket.makeRef(),\n      protocol: this.socket.protocol()\n    };\n    this.socketSend(\"Info\", info);\n  },\n\n  /* socketSend\n       Send data to Elm.\n       msg <string>\n          The message to send through the port.\n       payload <json>|<elm comparable>\n          The data to send.\n  */\n  socketSend: function socketSend(msg, payload) {\n    this.elmPorts.socketReceiver.send({\n      msg: msg,\n      payload: payload\n    });\n  },\n\n  /* log\n       Logs the message.\n       params <object>\n          kind <string>\n          msg <string>\n          data <object>\n  */\n  log: function log(params) {\n    if (this.socket.hasLogger && this.socket.hasLogger()) {\n      this.socket.log(params.kind, params.msg, params.data);\n    }\n  },\n  startLogging: function startLogging() {\n    this.socket.logger = this.logger;\n  },\n  stopLogging: function stopLogging() {\n    this.socket.logger = null;\n  },\n  logger: function logger(kind, msg, data) {\n    console.log(\"\".concat(kind, \": \").concat(msg), data);\n  },\n\n  /********** Channel **********/\n\n  /* join\n       Join a channel.\n       params <object>\n          topic <string>\n              The topic of the channel.\n           payload <maybe object>\n              Optional data to be sent to the channel, such as\n              authentication params.\n           events <list string>\n              The events expected to come from the channel.\n           timeout <maybe int>\n              Optional timeout in ms.\n  */\n  join: function join(params) {\n    var _this3 = this;\n\n    var channel = this.createChannel(params);\n    var join = {}; // Join the channel, with or without a custom timeout.\n\n    if (params.timeout) {\n      join = channel.join(params.timeout);\n    } else {\n      join = channel.join();\n    }\n\n    join.receive(\"ok\", function (payload) {\n      return _this3.channelSend(params.topic, \"JoinOk\", payload);\n    }).receive(\"error\", function (payload) {\n      return _this3.channelSend(params.topic, \"JoinError\", payload);\n    }).receive(\"timeout\", function () {\n      return _this3.channelSend(params.topic, \"JoinTimeout\", params.payload);\n    });\n  },\n  createChannel: function createChannel(params) {\n    var _this4 = this;\n\n    var channel = this.socket.channel(params.topic, params.payload);\n    channel.onClose(function () {\n      return _this4.channelSend(params.topic, \"Closed\", {});\n    });\n    channel.onError(function () {\n      return _this4.channelSend(params.topic, \"Error\", {});\n    });\n    channel.on(\"presence_diff\", function (diff) {\n      return _this4.onDiff(params.topic, diff);\n    });\n    channel.on(\"presence_state\", function (state) {\n      return _this4.onState(params.topic, state);\n    }); // Add the channel to the map of channels with the\n    // topic as the key, so that it can be selected by\n    // topic later.\n\n    this.channels[params.topic] = channel;\n    this.allOn(params);\n    return channel;\n  },\n\n  /* push\n       Push an event to the server with data.\n       params <object>\n          topic <string>\n              The topic of the channel to push to.\n           event <string>\n              The event to send to the channel.\n           payload <object>\n              The data to send.\n           timeout <maybe int>\n              The timeout before retrying.\n  */\n  push: function push(params) {\n    var _this5 = this;\n\n    // Select the channel to push to.\n    var channel = this.find(params.topic);\n    var push = {};\n    /* Push the event and payload to the server, with or without a custom\n       timeout.\n    */\n\n    if (params.timeout && params.payload) {\n      push = channel.push(params.event, params.payload, params.timeout);\n    } else if (params.payload) {\n      push = channel.push(params.event, params.payload);\n    } else {\n      push = channel.push(params.event, {});\n    }\n\n    push.receive(\"ok\", function (payload) {\n      return _this5.channelSend(params.topic, \"PushOk\", {\n        event: params.event,\n        payload: payload,\n        ref: params.ref\n      });\n    }).receive(\"error\", function (payload) {\n      return _this5.channelSend(params.topic, \"PushError\", {\n        event: params.event,\n        payload: payload,\n        ref: params.ref\n      });\n    }).receive(\"timeout\", function () {\n      return _this5.channelSend(params.topic, \"PushTimeout\", {\n        event: params.event,\n        payload: params.payload,\n        ref: params.ref\n      });\n    });\n  },\n\n  /* on\n       Subscribe to a channel event.\n       Store them it be re-used if a channel is disconnected by the user, so\n      that it doesn't have to be sent over again from Elm.\n       params <object>\n          topic <string>\n              The topic of the channel to subscribe to.\n           event <string>\n              The event to subscribe to.\n  */\n  on: function on(params) {\n    var channel = this.find(params.topic);\n    var events = this.events[params.topic];\n\n    if (channel && !events) {\n      this.events[params.topic] = [params.event];\n      this.subscribe(channel, params.topic, params.event);\n    } else if (channel && events && events.indexOf(params.event) == -1) {\n      events.push(params.event);\n      this.subscribe(channel, params.topic, params.event);\n    }\n  },\n\n  /* allOn\n       Subscribe to channel events.\n       Store them to be re-used if a channel is disconnected by the user, so\n      that they don't have to be sent over again from Elm.\n       params <object>\n          topic <string>\n              The topic of the channel to subscribe to.\n           events <list string>\n              The events to subscribe to.\n  */\n  allOn: function allOn(params) {\n    for (var i = 0; i < params.events.length; i++) {\n      this.on({\n        topic: params.topic,\n        event: params.events[i]\n      });\n    }\n  },\n  subscribe: function subscribe(channel, topic, event) {\n    var _this6 = this;\n\n    channel.on(event, function (payload) {\n      return _this6.channelSend(topic, \"Message\", {\n        event: event,\n        payload: payload\n      });\n    });\n  },\n\n  /* off\n       Turn off a subscription to a channel event.\n       params <object>\n          topic <string>\n              The topic of the channel to unsubscribe to.\n           event <string>\n              The event to unsubscribe to.\n  */\n  off: function off(params) {\n    var channel = this.find(params.topic);\n    var events = this.events[params.topic];\n\n    if (channel && events && events.indexOf(params.event) != -1) {\n      channel.off(params.event);\n      events.splice(events.indexOf(params.event), 1);\n    }\n  },\n\n  /* allOff\n       Turn off subscriptions to channel events.\n       params <object>\n          topic <string>\n              The topic of the channel to subscribe to.\n           events <list string>\n              The events to subscribe to.\n  */\n  allOff: function allOff(params) {\n    for (var i = 0; i < params.events.length; i++) {\n      this.off({\n        topic: params.topic,\n        event: params.events[i]\n      });\n    }\n  },\n\n  /* leave\n       Leave the channel.\n       params <object>\n          topic <string>\n              The topic of the channel to leave.\n           timeout <maybe int>\n              The timeout before retrying.\n  */\n  leave: function leave(params) {\n    var _this7 = this;\n\n    // Select the channel to leave.\n    var channel = this.find(params.topic);\n    this.events[params.topic] = [];\n    channel.leave(params.timeout).receive(\"ok\", function (_) {\n      return _this7.leaveOk(params.topic);\n    });\n  },\n\n  /* leaveOk\n       Callback after leaving a channel.\n       topic <string>\n          The topic of the channel to leave.\n  */\n  leaveOk: function leaveOk(topic) {\n    this.channelSend(topic, \"LeaveOk\", {});\n    delete this.find(topic);\n  },\n\n  /* find\n       Find a channel by topic.\n       topic <string>\n          The topic of the channel to find.\n  */\n  find: function find(topic) {\n    return this.channels[topic];\n  },\n\n  /* channelSend\n       Send data to Elm.\n       As we can't be certain the ports have been set up, make checks before\n      trying to send the data, and report any errors to the console.\n        topic <string>\n          The channel topic.\n       msg <string>\n          The message to send through the port.\n       payload <json>|<elm comparable>\n          The data to send.\n  */\n  channelSend: function channelSend(topic, msg, payload) {\n    this.elmPorts.channelReceiver.send({\n      topic: topic,\n      msg: msg,\n      payload: payload\n    });\n  },\n\n  /********** Presence **********/\n\n  /* onDiff\n       Called when a user presence joins or leaves.\n       topic <string>\n          The channel topic.\n       diff <object>\n          The diff received from Phoenix Presence.\n  */\n  onDiff: function onDiff(topic, diff) {\n    var _this8 = this;\n\n    var currentPresence = this.presences[topic] || {};\n    var newPresence = this.phoenixPresence.syncDiff(currentPresence, diff, function (id, current, newPres) {\n      return _this8.presenceSend(topic, \"Join\", _this8.packageForElm(id, newPres));\n    }, function (id, current, leftPres) {\n      return _this8.presenceSend(topic, \"Leave\", _this8.packageForElm(id, leftPres));\n    });\n    this.presenceSend(topic, \"Diff\", {\n      leaves: this.toList(diff.leaves),\n      joins: this.toList(diff.joins)\n    });\n    this.presenceSend(topic, \"State\", {\n      list: this.phoenixPresence.list(newPresence, function (id, metas) {\n        return _this8.packageForElm(id, metas);\n      })\n    });\n    this.presences[topic] = newPresence;\n  },\n\n  /* onState\n       Called when a user presence joins or leaves.\n       topic <string>\n          The channel topic.\n       state <object>\n          The state received from Phoenix Presence.\n  */\n  onState: function onState(topic, state) {\n    var _this9 = this;\n\n    var currentPresence = this.presences[topic];\n    var newPresence = this.phoenixPresence.syncState(currentPresence, state, function (id, current, newPres) {\n      return _this9.presenceSend(topic, \"Join\", _this9.packageForElm(id, newPres));\n    }, function (id, current, leftPres) {\n      return _this9.presenceSend(topic, \"Leave\", _this9.packageForElm(id, leftPres));\n    });\n    this.presenceSend(topic, \"State\", {\n      list: this.phoenixPresence.list(newPresence, function (id, presence) {\n        return _this9.packageForElm(id, presence);\n      })\n    });\n    this.presences[topic] = newPresence;\n  },\n\n  /* toList\n       List the presences in a consistent form that is easier to handle in\n      Elm.\n       presence <object>\n          The raw presence data received from the server.\n               {\"id1\": metas, \"id2\": metas, ... }\n       Returns:\n          [{id: \"id1\", metas: metas}, {id: \"id2\", metas: metas}, ... ]\n  */\n  toList: function toList(presence) {\n    var list = [];\n\n    for (var id in presence) {\n      list.push(this.packageForElm(id, presence[id]));\n    }\n\n    return list;\n  },\n\n  /* packageForElm\n       Package the presence into a consistent form that is easier to handle in\n      Elm.\n       id <string>\n          The user id.\n       presence <object>\n          The raw presence data received from the server.\n       The metas key will always be present.\n       The user key may be present if the fetch/2 callback is being used in\n      the Elixir Presence module to fetch user information from the DB.\n       The whole presence Object is also provided in order to enable decoding\n      of additional data stored on the Presence that can't be foreseen.\n  */\n  packageForElm: function packageForElm(id, presence) {\n    return {\n      id: id,\n      metas: presence.metas,\n      user: presence.user || null,\n      presence: presence\n    };\n  },\n\n  /* presenceSend\n       Send data to Elm.\n       As we can't be certain the ports have been set up, make checks before\n      trying to send the data, and report any errors to the console.\n       topic <string>\n          The channel topic.\n       msg <string>\n          The message to send through the port.\n       payload <json>|<elm comparable>\n          The data to send.\n  */\n  presenceSend: function presenceSend(topic, msg, payload) {\n    if (this.elmPorts.presenceReceiver) {\n      this.elmPorts.presenceReceiver.send({\n        topic: topic,\n        msg: msg,\n        payload: payload\n      });\n    } else {\n      console.warn(\"No presenceReceiver port found.\");\n    }\n  }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (ElmPhoenixWebSocket);\n\n//# sourceURL=webpack:///./js/elmPhoenixWebSocket.js?");

/***/ }),

/***/ 0:
/*!*************************!*\
  !*** multi ./js/app.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./js/app.js */\"./js/app.js\");\n\n\n//# sourceURL=webpack:///multi_./js/app.js?");

/***/ })

/******/ });